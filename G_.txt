request_type parse_request(recv_buffer *ps) {
 
 if(!strstr(ps->requestbuf,"\r\n\r\n"))
    return incomplete;
 
  if((strstr(ps->requestbuf,"GET /index.html" ) - ps->requestbuf == 0) || strstr(ps->requestbuf,"GET / ") - ps->requestbuf == 0)
    return root;
 
  if(strstr(ps->requestbuf,"POST /speak") - ps->requestbuf == 0)
    return speak;
  
  if(strstr(ps->requestbuf,"GET /listen") - ps->requestbuf == 0)
    return sse_listen;
}



void check_clients(pool *p) {
  int i, j, connfd, n, offset;
  char *end_of_uri;
  char *uri_ptr;
  char buf[4096];
  recv_buffer *rb;

  for (i = 0; (i <= p->maxi) && (p->nready > 0); i++) {
    connfd = p->clientfd[i];
    rb = &p->protos[i];
    offset = p->protos[i].first_empty_byte;

    if ((connfd > 0) && (FD_ISSET(connfd, &p->ready_set))) {
      p->nready--;
      // TODO: for the file descriptor that is ready, accumulate the received
      // bytes into the right receive buffer at the right offset, and keep
      // track of how many bytes have been received (so that you can keep
      // accumulating if more bytes come in).
      // Hint: don't forget to take care of the special case where the number
      // of bytes received is zero: that means that the client ended the
      // conversation (sent EOF).
      
      n = read(connfd, rb->requestbuf+rb->first_empty_byte, sizeof(rb->requestbuf) - rb->first_empty_byte);
      rb->first_empty_byte += n;
     
      if( n == 0){
        close_and_remove(p,i);
        continue;
      }

      // TODO: based on the bytes received, move the protocol forward and
      // potentially send some bytes back to the client(s).
      switch (parse_request(rb)) {
        case incomplete:
          break;
        case root:
         
          writen(connfd, OK, strlen(OK));          
          writen(connfd, indexhtml, strlen(indexhtml));          
          close_and_remove(p,i);
          break;
        case speak:
         
        extract_message(rb->requestbuf,buf);
        
          for(int x = 0; x < p->maxi; x++){
            if(p->clientfd[x] != -1 && p->receiving_events[x] == 1)
              writen(p->clientfd[x],buf,strlen(buf));
          }
          
           writen(connfd, OK, strlen(OK));           
           close_and_remove(p,i);         

          break;
        case sse_listen:
          
          p->receiving_events[i] = 1;         
          writen(connfd, stream, strlen(stream));

          break;
        default:
         
           writen(connfd, NOTOK, strlen(NOTOK));         
           close_and_remove(p,i);

          break;
      }
    }